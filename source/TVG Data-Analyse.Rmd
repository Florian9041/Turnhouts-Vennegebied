---
title: "TVG Data-Analyse"
author: "Florian Van Hecke"
date: "2024-12-09"
output: html_document
---

# packages laden
```{r setup, results ='hide', eval = TRUE, echo = FALSE, message = FALSE, cache = FALSE, purl = FALSE, warning = FALSE}
library(knitr)
opts_chunk$set(
  echo = FALSE, 
  eval = TRUE,  
  cache = FALSE, 
  autodep = TRUE,
  dpi = 300,
  fig.width = 150 / 25.4,
  fig.height = 100 / 25.4,
  warning = TRUE,
  error = TRUE,
  message = TRUE
)
# Enable inbo r-universe
options(repos = c(
    inbo = 'https://inbo.r-universe.dev',
    CRAN = 'https://cloud.r-project.org'))
library(dplyr)
library(ggplot2)
library(tidyr)
library(tibble)
library(scales)
library(purrr)
library(lubridate)
library(readxl)
library(stringr)
```

# data inlezen
```{r}
data_locaties <- read.csv(file = "./data/TVG_gemeten_plassen.csv", sep = ";")
data_TVG <- read.csv(file = "./data/FactResultAqua_bewerkt_2025-01-03.csv", sep = ";")
data_naamgeving <- read_xlsx("./data/Allocatie_3110_FC_incl_ventoponiemen.xlsx")
# Assuming 'date' is the column name for your dates
data_TVG$FieldSamplingDate <- as.Date(data_TVG$FieldSamplingDate)
data_TVG <- data_TVG %>% 
  left_join(data_naamgeving[,c(1,2)], by = "codeplas")

locaties <- data_locaties$codeplas
# gebruik locaties van TVG
data_TVG <- data_TVG %>%
  filter(codeplas %in% locaties)
unique(data_TVG$AquaComponent)
data_TVG <- data_TVG[!is.na(data_TVG$AquaComponent),]
data_TVG$FieldSamplingDate <- as.Date(data_TVG$FieldSamplingDate, format = "%Y-%m-%d")

# M als eenheid omzetten naar m
data_TVG$AquaUnit[data_TVG$AquaUnit == "M"] <- "m"
data_TVG$Unit[data_TVG$Unit == "M"] <- "m"

#habitattype <- data_TVG %>%
#  select(codeplas, HabtypeVel) %>%
#  unique() %>%
#  write.csv2(file = "./exports/habitattype.csv")


# verwijder data met ge√Øsoleerde metingen in 2024 (1 / 2 metingen in 2024)
data_TVG <- data_TVG %>%
  mutate(FieldSamplingDate = as.Date(FieldSamplingDate)) %>%
  group_by(codeplas) %>%
  # Identify codeplas with 1 or 2 distinct dates in 2024
  mutate(distinct_dates_2024 = n_distinct(FieldSamplingDate[year(FieldSamplingDate) == 2024])) %>%
  ungroup() %>%
  # Remove rows where the date is in 2024 and the codeplas has 1 or 2 distinct dates
  filter(!(year(FieldSamplingDate) == 2024 & distinct_dates_2024 >= 1 & distinct_dates_2024 <= 2)) %>%
  select(-distinct_dates_2024)  # Remove the helper column


data_TVG <- data_TVG %>%
  left_join(data_locaties[,c(2,7)], by = "codeplas")

data_TVG <- data_TVG %>%
  group_by(codeplas) %>%
  mutate(categorie = paste(watertype, 
                            str_extract(HabtypeVel, "^[^;,]+")))


# voeg ResultCalc toe als kolom voor meetwaarden onder detectielimiet
data_TVG <- data_TVG %>%
  mutate(ResultCalc = ifelse(grepl("<", ResultFormatted), 
                             as.numeric(gsub("<", "", ResultFormatted)) / 2, # als operator <, deel waarde door 2
                             as.numeric(gsub(">", "", ResultFormatted)))) # als > of geen operator, neem waarde over
# voeg label toe
data_TVG <- data_TVG %>%
  mutate(label = paste0(AquaComponent, " (", AquaUnit, ")"))

data_TVG <- data_TVG %>%
  mutate(meetreeks = case_when(
           FieldSamplingDate < as.Date("2020-01-01") ~ "<2020",TRUE ~ "2022-2024"), 
         seizoen = case_when(as.numeric(
           format(FieldSamplingDate, "%m")) %in% c(4:9) ~ "zomer",
           TRUE ~ "winter"))


# meetreeksen
data_TVG %>%
  ggplot(aes(x = FieldSamplingDate, y = codeplas, colour = meetreeks)) +
  geom_point(size = 1) +
    scale_x_date(date_breaks = "1 year", date_labels = "%Y")
  
meetreeksen <- read.csv(file = "./data/Turnhouts Vennegebied MKN - Meetreeksen.csv", sep = ",")
colnames(meetreeksen) <- c("codeplas", "2024", "2022-2023", "<2022", "<2022_jaar")
# reeks van 2022-2024
reeks_2022_2024 <- meetreeksen %>%
  filter(`2024` == "ja" | `2022-2023` == "ja") %>% pull(codeplas)
# historische metingen (die in 2022-2024 gemeten zijn)
reeks_2020 <- c("ANTTUR0304", "ANTTUR0301", "ANTTUR0296", "ANTTUR0094", "ANTTUR0082", "ANTTUR0065", "ANTRAV0293", "ANTRAV0230", "ANTRAV0052","ANTOTH0324", "ANTOTH0306", "ANTOTH0271")
```

## Anorganische data berekenen
```{r}
# voeg anorganische stikstof toe als variabele in tabel (N_anorg = NH4_N + NO3_N + NO2_N)
N_anorg <- data_TVG %>% group_by(codeplas, FieldSamplingDate) %>% 
  filter(AquaComponent %in% c("NH4_N", "NO3_N", "NO2_N")) %>% 
  summarise(N_anorg = sum(ResultCalc))
N_anorg <- N_anorg %>% 
  rename(ResultCalc = N_anorg)
N_anorg$label <- "N_anorg (mg N/l)"
N_anorg$AquaComponent <- "N_anorg"
N_anorg$AquaUnit <- "mg N/l"
N_anorg$Component <- "N_anorg"
N_anorg <- N_anorg %>%
  mutate(meetreeks = case_when(
           FieldSamplingDate < as.Date("2020-01-01") ~ "<2020",TRUE ~ "2022-2024"), 
         seizoen = case_when(as.numeric(
           format(FieldSamplingDate, "%m")) %in% c(4:9) ~ "zomer",
           TRUE ~ "winter"))
data_met_N_anorg <- bind_rows(data_TVG, N_anorg)
data_met_N_anorg <- data_met_N_anorg %>%
  left_join(data_locaties[,c(2,7)], by = "codeplas")
data_met_N_anorg <- data_met_N_anorg %>% 
  rename(watertype = watertype.y)

# data_met_N_anorg vervangt data_TVG
data_TVG <- data_met_N_anorg
```

# BOXPLOTS
## boxplots per variabele (basic loop)
```{r}
Componenten <- c("absorptie_440", "chl_a", "ZS_105", "ZS_550", "TP", "TN", "Cl", "SO4", "T_veld", "pH_veld", "EGV25_veld", "O2_veld", "O2verz", "SD_veld", "WD_veld", "NH4_N", "NO2_N", "NO3_N", "PO4_P", "alkaliniteit")

# meetreeks 2022-2024
for (Variabele in Componenten) {
  data_figuur <- data_TVG %>%
    filter(AquaComponent %in% Variabele & meetreeks == "2022-2024")
  figuur <- ggplot(data_figuur,
                   aes(x = ResultCalc, y = codeplas)) +
    geom_boxplot() +
    labs(title = paste0("Turnhout variabele ",data_figuur$label, "\n")) +
    ylab("Locatie") + xlab(paste0("Meetwaarde (", data_figuur$AquaUnit ,")"))
  ggsave(figuur,
         filename = paste0("./exports/boxplots2022_2024/", "Turnhout_",Variabele, "_bw",".jpg"), width = 1080, height = 720, units = "px", scale = 3)
}

# meetreeks <2020
for (Variabele in Componenten) {
  data_figuur <- data_TVG %>%
    filter(AquaComponent %in% Variabele & meetreeks == "<2020")
  figuur <- ggplot(data_figuur,
                   aes(x = ResultCalc, y = codeplas)) +
    geom_boxplot() +
    labs(title = paste0("Turnhout variabele ",data_figuur$label, "\n")) +
    ylab("Locatie") + xlab(paste0("Meetwaarde (", data_figuur$AquaUnit ,")"))
  ggsave(figuur,
         filename = paste0("./exports/boxplots2020/", "Turnhout_",Variabele, "_bw",".jpg"), width = 1080, height = 720, units = "px", scale = 3)
}
```

## Boxplots functie
```{r}
create_boxplot <- function(data_TVG, AquaComponent, vline, xlab) {
  # Calculate median values for sorting
  median_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(median = median(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(median)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- median_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    geom_vline(data = vline, aes(xintercept = xintercept, colour = watertype), 
               linetype = "solid", size = 1) +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}
# voormaximum
create_boxplot_max <- function(data_TVG, AquaComponent, vline, xlab) {
  # Calculate median values for sorting
  median_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(max = max(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(max)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- median_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    geom_vline(data = vline, aes(xintercept = xintercept, colour = watertype), 
               linetype = "solid", size = 1) +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}

# voor p90
create_boxplot_p90 <- function(data_TVG, AquaComponent, vline, xlab) {
  # Calculate median values for sorting
  median_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(p90 = quantile(ResultCalc, probs = 0.9, na.rm = TRUE), .groups = "drop") %>%
    arrange(p90)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- median_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    geom_vline(data = vline, aes(xintercept = xintercept, colour = watertype), 
               linetype = "solid", size = 1) +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}
```

## Boxplots functie log
```{r}
create_boxplot_log <- function(data_TVG, AquaComponent, vline, xlab) {
  # Calculate median values for sorting
  median_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(median = median(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(median)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- median_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = log10(ResultCalc), y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    geom_vline(data = vline, aes(xintercept = log10(xintercept), colour = watertype), 
               linetype = "solid", size = 1) +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}

# sorteer volgens maximum ipv mediaan
create_boxplot_log_max <- function(data_TVG, AquaComponent, vline, xlab) {
  # Calculate median values for sorting
  max_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(max = max(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(max)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- max_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = log10(ResultCalc), y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    geom_vline(data = vline, aes(xintercept = log10(xintercept), colour = watertype), 
               linetype = "solid", size = 1) +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}
```

## Boxplots functie geen grenswaarden (met en zonder log)
```{r}
create_boxplot_basic <- function(data_TVG, AquaComponent, xlab) {
  # Calculate median values for sorting
  median_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(median = median(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(median)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- median_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}

create_boxplot_basic_max <- function(data_TVG, AquaComponent, xlab) {
  # Calculate median values for sorting
  max_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(max = max(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(max)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- max_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}
# met logaritmische transformatie

create_boxplot_basiclog <- function(data_TVG, AquaComponent, xlab) {
  # Calculate median values for sorting
  median_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(median = median(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(median)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- median_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = log10(ResultCalc), y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}

create_boxplot_basiclog_max <- function(data_TVG, AquaComponent, xlab) {
  # Calculate median values for sorting
  max_values <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(codeplas, watertype) %>%
    summarise(max = max(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
    arrange(max)  # Sort in ascending order
  
  # Create a factor level for codeplas based on sorted median values
  codeplas_order <- max_values$codeplas
  
  # Create the main plot
  plot <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
    ggplot(aes(x = log10(ResultCalc), y = codeplas, colour = watertype)) +
    geom_boxplot() +
    facet_grid(watertype ~ ., scales = "free", space = "free_y") +
    xlab(xlab)

  # Create a dataset for labels
  labels_data <- data_TVG %>%
    filter(AquaComponent == !!AquaComponent & meetreeks == "2022-2024") %>%
    group_by(watertype, codeplas) %>%
    summarise(Locatie = first(Locatie), .groups = "drop") %>%
    mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
           x_pos = Inf)  # Position labels at the right edge of the plot

  # Add labels to the plot
  final_plot <- plot + 
    geom_text(data = labels_data, 
              aes(x = x_pos, y = codeplas, label = Locatie),
              hjust = 1,  # Right-align the text
              vjust = 0.5,  # Center-align vertically
              size = 3.5,  # Adjust text size as needed
              colour = "black") +  # Set label color
    theme(
      legend.position = "none",
      axis.title.y = element_blank()
    )

  return(final_plot)
}
```

## Boxplots
```{r}
# chloride
vline_Cl <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept = c(140, 70, 50, 20, 20)
)
create_boxplot_p90(data_TVG, "Cl", vline_Cl, "Chloride-concentratie (mg/l)")

# elektrische geleidbaarheid
vline_EGV <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept = c(750, 350, 350, 100, 100)
)
create_boxplot_p90(data_TVG, "EGV25_veld", vline_EGV, "Elektrische geleidbaarheid (¬µS/cm)")

# temperatuur
vline_Temp <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept <- 25
)
create_boxplot_max(data_TVG, "T_veld", vline_Temp, "Temperatuur (¬∞C)")

# zuurstofconcentratie
vline_O2c <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept <- 6
)
create_boxplot(data_TVG, "O2_veld", vline_O2c, "Zuurstofconcentratie (mg/l)")


# zuurstofverzadiging
vline_O2v <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept <- 120
)
create_boxplot_max(data_TVG, "O2verz", vline_O2v, "Zuurstofverzadiging (%)")

# chlorofyl-a
vline_chla <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept <- 10
)
create_boxplot(data_TVG, "chl_a", vline_chla, "Chlorofyl_a (¬µg/l)")
create_boxplot_log(data_TVG, "chl_a", vline_chla, "Chlorofyl_a (log10 ¬µg/l)")

# Sulfaat
vline_SO4 <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept = c(100, 50, 40, 15, 15)
)
create_boxplot(data_TVG, "SO4", vline_SO4, "Sulfaat-concentratie (mg/l)")
create_boxplot_log(data_TVG, "SO4", vline_SO4, "Sulfaat-concentratie (log10 mg/l)")

# Totale stikstof TN
vline_TN <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept = c(1, 1.3, 1.3, 1.3, 1.3)
)
create_boxplot(data_TVG %>% filter(seizoen == "zomer"), "TN", vline_TN, "Totale stikstof (mg N/l)")
create_boxplot_log(data_TVG %>% filter(seizoen == "zomer"), "TN", vline_TN, "Totale stikstof (log10 mg N/l)")

# Totale fosfor TP
vline_TP <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept = c(0.04, 0.04, 0.03, 0.03, 0.03)
)
create_boxplot(data_TVG %>% filter(seizoen == "zomer"), "TP", vline_TP, "Totale fosfor (mg P/l)")
create_boxplot_log(data_TVG %>% filter(seizoen == "zomer"), "TP", vline_TP, "Totale fosfor (log10 mg P/l)")

# PO4_P
create_boxplot_basic_max(data_TVG, "PO4_P", "Orthofosfaat (mg P/l)")

# Zwevende stof 105 & 550
create_boxplot_basic_max(data_TVG, "ZS_105", "Zwevende stof (mg/l 105¬∞)")
create_boxplot_basic_max(data_TVG, "ZS_550", "Zwevende stof (mg/l 550¬∞)")

# absorptie
create_boxplot_basic(data_TVG, "absorptie_440", "Absorptie 440nm (ABS)")
create_boxplot_basiclog(data_TVG, "absorptie_440", "Absorptie 440nm (log10 ABS)")

# NH4_N
create_boxplot_basic_max(data_TVG, "NH4_N", "NH4_N (mg N/l)")
create_boxplot_basiclog_max(data_TVG, "NH4_N", "NH4_N (log10 mg N/l)")

# NO3_N
create_boxplot_basic(data_TVG, "NO3_N", "NO3_N (mg N/l)")
create_boxplot_basiclog(data_TVG, "NO3_N", "NO3_N (log10 mg N/l)")
create_boxplot_basiclog_max(data_TVG, "NO3_N", "NO3_N (log10 mg N/l)")


# NO2_N
create_boxplot_basic_max(data_TVG, "NO2_N", "NO2_N (mg N/l)")
create_boxplot_basiclog_max(data_TVG, "NO2_N", "NO2_N (log10 mg N/l)")

# Anorganische stikstof
vline_N_anorg <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept <- 0.14
)
create_boxplot(data_met_N_anorg, "N_anorg", vline_N_anorg, "Anorganische stikstof (mg N/l)")
create_boxplot_log_max(data_met_N_anorg, "N_anorg", vline_N_anorg, "Anorganische stikstof (log10 mg N/l)")


```


## Boxplots pH min - max
```{r}
vline_pH <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xinterceptmin = c(6.5, 5.5, 5.5, 4.5, 4.5),
  xinterceptmax = c(8.5, 7.5, 7.5, 6.5, 6.5)
)

# Calculate median values for sorting
median_values <- data_TVG %>%
  filter(AquaComponent == "pH_veld" & meetreeks == "2022-2024") %>%
  group_by(codeplas, watertype) %>%
  summarise(median = median(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
  arrange(median)  # Sort in ascending order

# Create a factor level for codeplas based on sorted median values
codeplas_order <- median_values$codeplas

# Create the main plot
plot <- data_TVG %>%
  filter(AquaComponent == "pH_veld" & meetreeks == "2022-2024") %>%
  mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
  ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
  geom_boxplot() +
  facet_grid(watertype ~ ., scales = "free", space = "free_y") +
  geom_vline(data = vline_pH, aes(xintercept = xinterceptmin, colour = watertype), 
             linetype = "solid", size = 1) +
  geom_vline(data = vline_pH, aes(xintercept = xinterceptmax, colour = watertype), 
             linetype = "solid", size = 1) + 
  xlab("Zuurtegraad - pH")

# Create a dataset for labels
labels_data <- data_TVG %>%
  filter(AquaComponent == "pH_veld" & meetreeks == "2022-2024") %>%
  group_by(watertype, codeplas) %>%
  summarise(Locatie = first(Locatie), .groups = "drop") %>%
  mutate(codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
         x_pos = Inf)  # Position labels at the right edge of the plot

# Add labels to the plot
plot + 
  geom_text(data = labels_data, 
            aes(x = x_pos, y = codeplas, label = Locatie),
            hjust = 1,  # Right-align the text
            vjust = 0.5,  # Center-align vertically
            size = 3.5,  # Adjust text size as needed
            colour = "black") +  # Set label color
  theme(
    legend.position = "none",
    axis.title.y = element_blank()
  )

```

## Boxplots Secchi-diepte en waterdiepte
```{r}
vline_SD <- data.frame(
  watertype = c("Aw-om", "Cb", "Czb", "Zm", "Zs"),
  xintercept = 0.9
)

data_SD_WD <- data_TVG %>% 
  filter(AquaComponent %in% c("SD_veld", "WD_veld") & meetreeks == "2022-2024") %>%
  group_by(codeplas, AquaComponent) %>%
  mutate(gemiddelde = mean(ResultCalc, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(codeplas) %>%
  mutate(Bodemzicht = case_when(
    all(gemiddelde[AquaComponent == "SD_veld"] >= 0.9 * gemiddelde[AquaComponent == "WD_veld"]) ~ "ja",
    TRUE ~ "nee"
  )) %>% 
  ungroup()

# Calculate median values for sorting
median_values <- data_SD_WD %>%
  filter(AquaComponent == "SD_veld") %>%
  group_by(codeplas, watertype) %>%
  summarise(median = median(ResultCalc, na.rm = TRUE), .groups = "drop") %>%
  arrange(median)  # Sort in ascending order

# Create a factor level for codeplas based on sorted median values
codeplas_order <- median_values$codeplas

# Create a dataset for labels
labels_data <- data_SD_WD %>%
  filter(AquaComponent == "SD_veld") %>%
  group_by(watertype, codeplas) %>%
  summarise(Locatie = first(Locatie), .groups = "drop") %>%
  mutate(
    codeplas = factor(codeplas, levels = codeplas_order),  # Set factor levels
    x_pos = Inf  # Position labels at the right edge of the plot
  )

# Create the plot
p <- data_SD_WD %>% 
  filter(AquaComponent == "SD_veld") %>%
  mutate(codeplas = factor(codeplas, levels = codeplas_order)) %>%  # Set factor levels
  ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype, fill = Bodemzicht)) +
  geom_boxplot() +
  xlab("Secchi-diepte (m)") +
  facet_grid(watertype ~ ., scales = "free", space = "free_y") +
  geom_vline(data = vline_SD, aes(xintercept = xintercept, colour = watertype),
             linetype = "solid", size = 1) +
  scale_x_continuous(breaks = pretty_breaks(n = 10)) +
  scale_fill_manual(values = c("ja" = "lightblue", "nee" = "grey")) +
  theme(
      legend.position = "none",
      axis.title.y = element_blank(),
      plot.margin = margin(r = 100)) +  # Increase right margin for labels
  guides(colour = guide_legend(title = "Watertype"),
         fill = guide_legend(title = "Bodemzicht")) +
  geom_text(data = labels_data, 
          aes(x = x_pos, y = codeplas, label = Locatie),
          inherit.aes = FALSE,
          hjust = 1,
          vjust = 0.5,
          size = 3.5,
          colour = "black") +  # Set label color
  coord_cartesian(clip = "off")  # Allow drawing outside the plot area

print(p)

```


## Boxplots Alkaliniteit (geen grenswaarden)
```{r}
create_boxplot_basic(data_TVG, "alkaliniteit", "Alkaliniteit (meq/l)")
create_boxplot_basiclog(data_TVG, "alkaliniteit", "Alkaliniteit (log10 meq/l)")
```

# TIJDSREEKSEN
## functie voor tijdsreeksen
```{r}
generate_plot <- function(codeplas_value, aqua_component, watertype_thresholds, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent == aqua_component & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data$watertype)
  threshold <- watertype_thresholds[[watertype]] %||% NA # Use NA if not found
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    geom_hline(yintercept = threshold, linetype = "dashed", color = "black", size = 1) +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
    
  
  return(plot)
}

generate_multiple_plots <- function(codeplas_values, aqua_component, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot(.x, aqua_component, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# voor data_met_N_anorg
generate_plot_N_anorg <- function(codeplas_value, aqua_component, watertype_thresholds, y_label = NULL) {
  filtered_data <- data_met_N_anorg %>%
    filter(AquaComponent == aqua_component & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data$watertype)
  threshold <- watertype_thresholds[[watertype]] %||% NA # Use NA if not found
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    geom_hline(yintercept = threshold, linetype = "dashed", color = "black", size = 1) +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
    
  
  return(plot)
}

generate_multiple_plots_N_anorg <- function(codeplas_values, aqua_component, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_N_anorg(.x, aqua_component, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}


```

### voor <2020
```{r}
generate_plot_2020 <- function(codeplas_value, aqua_component, watertype_thresholds, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent == aqua_component & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data$watertype)
  threshold <- watertype_thresholds[[watertype]] %||% NA # Use NA if not found
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    geom_hline(yintercept = threshold, linetype = "dashed", color = "black", size = 1) +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
    
  
  return(plot)
}

generate_multiple_plots_2020 <- function(codeplas_values, aqua_component, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020(.x, aqua_component, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# geen grenswaarden
generate_plot_2020_nohline <- function(codeplas_value, aqua_component, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent == aqua_component & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
    
  
  return(plot)
}

generate_multiple_plots_2020_nohline <- function(codeplas_values, aqua_component, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020_nohline(.x, aqua_component, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# voor 2 variabelen
generate_plot_2020_2 <- function(codeplas_value, aqua_component1, aqua_component2, watertype_thresholds, y_label = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data1$watertype)
  threshold <- watertype_thresholds[[watertype]] %||% NA # Use NA if not found
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_hline(yintercept = threshold, linetype = "dashed", color = "black", size = 1) +
    labs(y = y_axis_label,
         color = "AquaComponent") +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.text = element_text(size = 14),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2020_2 <- function(codeplas_values, aqua_component1, aqua_component2, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020_2(.x, aqua_component1, aqua_component2, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# 2 variabelen zonder normgrenzen
generate_plot_2020_2_nohline <- function(codeplas_value, aqua_component1, aqua_component2, y_label = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    labs(y = y_axis_label,
         color = "AquaComponent") +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.text = element_text(size = 14),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2020_2_nohline <- function(codeplas_values, aqua_component1, aqua_component2, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020_2_nohline(.x, aqua_component1, aqua_component2, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

```

### figuren <2020
```{r}
# Chloride
grenswaarden_Cl <- list(
  "Aw-om" = 140, 
  "Cb" = 70, 
  "Czb" = 50, 
  "Zm" = 20, 
  "Zs" = 20
)

plots_Cl2020 <- generate_multiple_plots_2020(reeks_2020, "Cl", grenswaarden_Cl, "Chloride (mg/l)")
walk2(plots_Cl2020, names(plots_Cl2020),
      ~ggsave(filename = paste0("./exports/Chloride2020/", .y, "_", "Cl2020", ".png"), plot = .x, width = 10, height = 6))

# Elektrische geleidbaarheid
grenswaarden_EGV <- list(
  "Aw-om" = 750, 
  "Cb" = 350, 
  "Czb" = 250, 
  "Zm" = 100, 
  "Zs" = 100
)

plots_EGV <- generate_multiple_plots_2020(reeks_2020, "EGV25_veld", grenswaarden_EGV, "Elektrische geleidbaarheid (¬µS/cm)")
walk2(plots_EGV, names(plots_EGV),
      ~ggsave(filename = paste0("./exports/Elektrische_geleidbaarheid2020/", .y, "_", "EGV2020", ".png"), plot = .x, width = 10, height = 6))

# Temperatuur
grenswaarden_Temp <- list(
  "Aw-om" = 25, 
  "Cb" = 25, 
  "Czb" = 25, 
  "Zm" = 25, 
  "Zs" = 25
)

plots_Temp <- generate_multiple_plots_2020(reeks_2020, "T_veld", grenswaarden_Temp, "Temperatuur (¬∞C)")
walk2(plots_Temp, names(plots_Temp),
      ~ggsave(filename = paste0("./exports/Temperatuur2020/", .y, "_", "Temp2020", ".png"), plot = .x, width = 10, height = 6))

# Zuurstofverzadiging
grenswaarden_O2verz <- list(
  "Aw-om" = 120, 
  "Cb" = 120, 
  "Czb" = 120, 
  "Zm" = 120, 
  "Zs" = 120
)

plots_O2v <- generate_multiple_plots_2020(reeks_2020, "O2verz", grenswaarden_O2verz, "Zuurstofverzadiging (%)")
walk2(plots_O2v, names(plots_O2v),
      ~ggsave(filename = paste0("./exports/Zuurstofverzadiging2020/", .y, "_", "O2verz2020", ".png"), plot = .x, width = 10, height = 6))

# Zuurstofconcentratie
grenswaarden_O2conc <- list(
  "Aw-om" = 6, 
  "Cb" = 6, 
  "Czb" = 6, 
  "Zm" = 6, 
  "Zs" = 6
)

plots_O2c <- generate_multiple_plots_2020(reeks_2020, "O2_veld", grenswaarden_O2conc, "Zuurstofconcentratie (mg/l)")
walk2(plots_O2c, names(plots_O2c),
      ~ggsave(filename = paste0("./exports/Zuurstofconcentratie2020/", .y, "_", "O2conc2020", ".png"), plot = .x, width = 10, height = 6))


# Chlorofyl-a
grenswaarden_chla <- list(
  "Aw-om" = 10, 
  "Cb" = 10, 
  "Czb" = 10, 
  "Zm" = 10, 
  "Zs" = 10
)

plots_chla_2020 <- generate_multiple_plots_2020(reeks_2020, "chl_a", grenswaarden_chla, "Chlorofyl_a (¬µg/l)")
walk2(plots_chla_2020, names(plots_chla_2020),
      ~ggsave(filename = paste0("./exports/Chlorofyl_a2020/", .y, "_", "chl_a2020", ".png"), plot = .x, width = 10, height = 6))

# Sulfaat - SO4
grenswaarden_SO4 <- list(
  "Aw-om" = 100, 
  "Cb" = 50, 
  "Czb" = 40, 
  "Zm" = 15, 
  "Zs" = 15
)

plots_SO4_2020 <- generate_multiple_plots_2020(reeks_2020, "SO4", grenswaarden_SO4, "Sulfaat (mg/l)")
walk2(plots_SO4_2020, names(plots_SO4_2020),
      ~ggsave(filename = paste0("./exports/SO4_2020/", .y, "_", "SO4_2020", ".png"), plot = .x, width = 10, height = 6))

# Alkaliniteit
plots_alk_2020 <- generate_multiple_plots_2020_nohline(reeks_2020, "alkaliniteit", "Alkaliniteit (meq/l)")
walk2(plots_alk_2020, names(plots_alk_2020),
      ~ggsave(filename = paste0("./exports/alkaliniteit2020/", .y, "_", "abs2020", ".png"), plot = .x, width = 10, height = 6))

# TN - Totale stikstof
grenswaarden_TN <- list(
  "Aw-om" = 1, 
  "Cb" = 1.3, 
  "Czb" = 1.3, 
  "Zm" = 1.3, 
  "Zs" = 1.3
)
## geen data voor verschillende locaties voor TN
plots_TN_2020 <- generate_multiple_plots_2020(c("ANTTUR0296", "ANTTUR0094", "ANTTUR0082", "ANTRAV0293", "ANTRAV0230", "ANTRAV0052", "ANTOTH0324", "ANTOTH0306"), "TN", grenswaarden_TN, "Totale stikstof (mg N/l)")
walk2(plots_TN_2020, names(plots_TN_2020),
      ~ggsave(filename = paste0("./exports/TN2020/", .y, "_", "TN2020", ".png"), plot = .x, width = 10, height = 6))


# TP - Totale fosfor
grenswaarden_TP <- list(
  "Aw-om" = 0.04, 
  "Cb" = 0.04, 
  "Czb" = 0.03, 
  "Zm" = 0.03, 
  "Zs" = 0.03
)

plots_TP_2020 <- generate_multiple_plots_2020(reeks_2020, "TP", grenswaarden_TP, "Totale fosfor (mg P/l)")
walk2(plots_TP_2020, names(plots_TP_2020),
      ~ggsave(filename = paste0("./exports/TP2020/", .y, "_", "TP2020", ".png"), plot = .x, width = 10, height = 6))


# Absorptie 440 (geen norm)
plots_abs_2020 <- generate_multiple_plots_2020_nohline(reeks_2020, "absorptie_440", "Absorptie (ABS)")
walk2(plots_abs_2020, names(plots_abs_2020),
      ~ggsave(filename = paste0("./exports/absorptie2020/", .y, "_", "abs2020", ".png"), plot = .x, width = 10, height = 6))

# Fosfaat - fosfor PO4_P
plots_PO4_P_2020 <- generate_multiple_plots_2020_nohline(reeks_2020, "PO4_P", "PO4-P (mg P/l)")
walk2(plots_PO4_P_2020, names(plots_PO4_P_2020),
      ~ggsave(filename = paste0("./exports/PO4_P2020/", .y, "_", "PO4_P2020", ".png"), plot = .x, width = 10, height = 6))

# Anorganische stikstof
grenswaarden_Nanorg <- list(
  "Aw-om" = 0.14, 
  "Cb" = 0.14, 
  "Czb" = 0.14, 
  "Zm" = 0.14, 
  "Zs" = 0.14
)

plots_N_anorg_2020 <- generate_multiple_plots_2020(reeks_2020, "N_anorg", grenswaarden_Nanorg,  "Anorganische stikstof (mg N/l)")
walk2(plots_N_anorg_2020, names(plots_N_anorg_2020),
      ~ggsave(filename = paste0("./exports/N_anorg2020/", .y, "_", "N_anorg2020", ".png"), plot = .x, width = 10, height = 6))


# ZS105_550
plots_ZS105_550_2020 <- generate_multiple_plots_2_nohline_2020(reeks_2020, "ZS_105", "ZS_550", "Zwevende stof (mg/l)")
walk2(plots_ZS105_550_2020, names(plots_ZS105_550_2020),
      ~ggsave(filename = paste0("./exports/ZS105_550_2020/", .y, "_", "ZS105_550_2020", ".png"), plot = .x, width = 10, height = 6))
```


## functie voor tijdsreeksen zonder grenswaarde
```{r}
generate_plot_nohline <- function(codeplas_value, aqua_component, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent == aqua_component & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
    
  
  return(plot)
}

generate_multiple_plots_nohline <- function(codeplas_values, aqua_component, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_nohline(.x, aqua_component, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

```

## code voor 2 variabelen te plotten (vb WD en SD, ZS105 en ZS550)
```{r}
generate_plot_2 <- function(codeplas_value, aqua_component1, aqua_component2, watertype_thresholds, y_label = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data1$watertype)
  threshold <- watertype_thresholds[[watertype]] %||% NA # Use NA if not found
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_hline(yintercept = threshold, linetype = "dashed", color = "black", size = 1) +
    labs(y = y_axis_label,
         color = "AquaComponent") +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.text = element_text(size = 14),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2 <- function(codeplas_values, aqua_component1, aqua_component2, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2(.x, aqua_component1, aqua_component2, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# zonder normgrenzen
generate_plot_2_nohline <- function(codeplas_value, aqua_component1, aqua_component2, y_label = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    labs(y = y_axis_label,
         color = "AquaComponent") +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.text = element_text(size = 14),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2_nohline <- function(codeplas_values, aqua_component1, aqua_component2, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2_nohline(.x, aqua_component1, aqua_component2, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# < 2020
generate_plot_2_2020 <- function(codeplas_value, aqua_component1, aqua_component2, watertype_thresholds, y_label = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data1$watertype)
  threshold <- watertype_thresholds[[watertype]] %||% NA # Use NA if not found
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_hline(yintercept = threshold, linetype = "dashed", color = "black", size = 1) +
    labs(y = y_axis_label,
         color = "AquaComponent") +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.text = element_text(size = 14),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2_2020 <- function(codeplas_values, aqua_component1, aqua_component2, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2_2020(.x, aqua_component1, aqua_component2, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# zonder normgrenzen
generate_plot_2_nohline_2020 <- function(codeplas_value, aqua_component1, aqua_component2, y_label = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    labs(y = y_axis_label,
         color = "AquaComponent") +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.text = element_text(size = 14),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2_nohline_2020 <- function(codeplas_values, aqua_component1, aqua_component2, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2_nohline_2020(.x, aqua_component1, aqua_component2, y_label))
  names(plots) <- codeplas_values
  return(plots)
}
```

## functie tijdsreeks met 2 variabelen op 1 figuur
```{r}
generate_plot_two_components <- function(codeplas_value, aqua_component1, aqua_component2, y_label1 = NULL, y_label2 = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  y_axis_label1 <- if(is.null(y_label1)) paste("ResultCalc", aqua_component1) else y_label1
  y_axis_label2 <- if(is.null(y_label2)) paste("ResultCalc", aqua_component2) else y_label2
  
  # Calculate the scaling factor
  scale_factor <- max(filtered_data2$ResultCalc, na.rm = TRUE) / max(filtered_data1$ResultCalc, na.rm = TRUE)
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc / scale_factor, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc / scale_factor, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(name = y_axis_label1, 
                       sec.axis = sec_axis(~. * scale_factor, name = y_axis_label2)) +
    scale_color_manual(values = c("orange", "blue4")) +
    labs(color = "AquaComponent") +
    theme(
      legend.position = "none",
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      axis.title.y.left = element_text(color = "orange"),
      axis.text.y.left = element_text(color = "orange"),
      axis.title.y.right = element_text(color = "blue4"),
      axis.text.y.right = element_text(color = "blue4"),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_two_components <- function(codeplas_values, aqua_component1, aqua_component2, y_label1 = NULL, y_label2 = NULL) {
  plots <- map(codeplas_values, ~generate_plot_two_components(.x, aqua_component1, aqua_component2, y_label1, y_label2))
  names(plots) <- codeplas_values
  return(plots)
}

# voor <2020
generate_plot_two_components_2020 <- function(codeplas_value, aqua_component1, aqua_component2, y_label1 = NULL, y_label2 = NULL) {
  filtered_data1 <- data_TVG %>%
    filter(AquaComponent == aqua_component1 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  filtered_data2 <- data_TVG %>%
    filter(AquaComponent == aqua_component2 & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- max(nrow(filtered_data1), nrow(filtered_data2))
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  y_axis_label1 <- if(is.null(y_label1)) paste("ResultCalc", aqua_component1) else y_label1
  y_axis_label2 <- if(is.null(y_label2)) paste("ResultCalc", aqua_component2) else y_label2
  
  # Calculate the scaling factor
  scale_factor <- max(filtered_data2$ResultCalc, na.rm = TRUE) / max(filtered_data1$ResultCalc, na.rm = TRUE)
  
  plot <- ggplot() +
    geom_line(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1), linewidth = 1) +
    geom_point(data = filtered_data1, aes(x = FieldSamplingDate, y = ResultCalc, color = aqua_component1)) +
    geom_line(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc / scale_factor, color = aqua_component2), linewidth = 1) +
    geom_point(data = filtered_data2, aes(x = FieldSamplingDate, y = ResultCalc / scale_factor, color = aqua_component2)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(name = y_axis_label1, 
                       sec.axis = sec_axis(~. * scale_factor, name = y_axis_label2)) +
    scale_color_manual(values = c("orange", "blue4")) +
    labs(color = "AquaComponent") +
    theme(
      legend.position = "none",
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      axis.title.y.left = element_text(color = "orange"),
      axis.text.y.left = element_text(color = "orange"),
      axis.title.y.right = element_text(color = "blue4"),
      axis.text.y.right = element_text(color = "blue4"),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_two_components_2020 <- function(codeplas_values, aqua_component1, aqua_component2, y_label1 = NULL, y_label2 = NULL) {
  plots <- map(codeplas_values, ~generate_plot_two_components(.x, aqua_component1, aqua_component2, y_label1, y_label2))
  names(plots) <- codeplas_values
  return(plots)
}


```

## tijdreeksen aparte y-as 2 variabelen
```{r}
# Zuurtegraad en absorptie
plots_pH_abs <- generate_multiple_plots_two_components(reeks_2022_2024, "pH_veld", "absorptie_440", "Zuurtegraad - pH", "Absorptie (440nm ABS)")
walk2(plots_pH_abs, names(plots_pH_abs),
      ~ggsave(filename = paste0("./exports/pH_abs/", .y, "_", "pH_abs", ".png"), plot = .x, width = 10, height = 6))

## < 2020
plots_pH_abs2020 <- generate_multiple_plots_two_components_2020(reeks_2020, "pH_veld", "absorptie_440", "Zuurtegraad - pH", "Absorptie (440nm ABS)")
walk2(plots_pH_abs2020, names(plots_pH_abs2020),
      ~ggsave(filename = paste0("./exports/pH_abs2020/", .y, "_", "pH_abs2020", ".png"), plot = .x, width = 10, height = 6))


# chlorofyl_a en absorptie
plots_chla_abs <- generate_multiple_plots_two_components(reeks_2022_2024, "chl_a", "absorptie_440", "Chlorofyl-a (¬µg/l)", "Absorptie (440nm ABS)")
walk2(plots_chla_abs, names(plots_chla_abs),
      ~ggsave(filename = paste0("./exports/chla_abs/", .y, "_", "chla_abs", ".png"), plot = .x, width = 10, height = 6))

## < 2020
plots_chla_abs2020 <- generate_multiple_plots_two_components_2020(reeks_2020, "chl_a", "absorptie_440", "Chlorofyl-a (¬µg/l)", "Absorptie (440nm ABS)")
walk2(plots_chla_abs2020, names(plots_chla_abs2020),
      ~ggsave(filename = paste0("./exports/chla_abs2020/", .y, "_", "chla_abs2020", ".png"), plot = .x, width = 10, height = 6))
```


### figuren 2022-2024
```{r}
# Chloride
grenswaarden_Cl <- list(
  "Aw-om" = 140, 
  "Cb" = 70, 
  "Czb" = 50, 
  "Zm" = 20, 
  "Zs" = 20
)

plots_Cl <- generate_multiple_plots(reeks_2022_2024, "Cl", grenswaarden_Cl, "Chloride (mg/l)")
walk2(plots_Cl, names(plots_Cl),
      ~ggsave(filename = paste0("./exports/Chloride/", .y, "_", "Cl", ".png"), plot = .x, width = 10, height = 6))


# Elektrische geleidbaarheid
grenswaarden_EGV <- list(
  "Aw-om" = 750, 
  "Cb" = 350, 
  "Czb" = 250, 
  "Zm" = 100, 
  "Zs" = 100
)

plots_EGV <- generate_multiple_plots(reeks_2022_2024, "EGV25_veld", grenswaarden_EGV, "Elektrische geleidbaarheid (¬µS/cm)")
walk2(plots_EGV, names(plots_EGV),
      ~ggsave(filename = paste0("./exports/Elektrische_geleidbaarheid/", .y, "_", "EGV", ".png"), plot = .x, width = 10, height = 6))


# Temperatuur
grenswaarden_Temp <- list(
  "Aw-om" = 25, 
  "Cb" = 25, 
  "Czb" = 25, 
  "Zm" = 25, 
  "Zs" = 25
)

plots_Temp <- generate_multiple_plots(reeks_2022_2024, "T_veld", grenswaarden_Temp, "Temperatuur (¬∞C)")
walk2(plots_Temp, names(plots_Temp),
      ~ggsave(filename = paste0("./exports/Temperatuur/", .y, "_", "Temp", ".png"), plot = .x, width = 10, height = 6))

# Zuurstofverzadiging
grenswaarden_O2verz <- list(
  "Aw-om" = 120, 
  "Cb" = 120, 
  "Czb" = 120, 
  "Zm" = 120, 
  "Zs" = 120
)

plots_O2v <- generate_multiple_plots(reeks_2022_2024, "O2verz", grenswaarden_O2verz, "Zuurstofverzadiging (%)")
walk2(plots_O2v, names(plots_O2v),
      ~ggsave(filename = paste0("./exports/Zuurstofverzadiging/", .y, "_", "O2verz", ".png"), plot = .x, width = 10, height = 6))

# Zuurstofconcentratie
grenswaarden_O2conc <- list(
  "Aw-om" = 6, 
  "Cb" = 6, 
  "Czb" = 6, 
  "Zm" = 6, 
  "Zs" = 6
)

plots_O2c <- generate_multiple_plots(reeks_2022_2024, "O2_veld", grenswaarden_O2conc, "Zuurstofconcentratie (mg/l)")
walk2(plots_O2c, names(plots_O2c),
      ~ggsave(filename = paste0("./exports/Zuurstofconcentratie/", .y, "_", "O2conc", ".png"), plot = .x, width = 10, height = 6))


# Chlorofyl-a
grenswaarden_chla <- list(
  "Aw-om" = 10, 
  "Cb" = 10, 
  "Czb" = 10, 
  "Zm" = 10, 
  "Zs" = 10
)

plots_chla <- generate_multiple_plots(reeks_2022_2024, "chl_a", grenswaarden_chla, "Chlorofyl_a (¬µg/l)")
walk2(plots_chla, names(plots_chla),
      ~ggsave(filename = paste0("./exports/Chlorofyl_a/", .y, "_", "chl_a", ".png"), plot = .x, width = 10, height = 6))

# TN - Totale stikstof
grenswaarden_TN <- list(
  "Aw-om" = 1, 
  "Cb" = 1.3, 
  "Czb" = 1.3, 
  "Zm" = 1.3, 
  "Zs" = 1.3
)

plots_TN <- generate_multiple_plots(reeks_2022_2024, "TN", grenswaarden_TN, "Totale stikstof (mg N/l)")
walk2(plots_TN, names(plots_TN),
      ~ggsave(filename = paste0("./exports/TN/", .y, "_", "TN", ".png"), plot = .x, width = 10, height = 6))

# TP - Totale fosfor
grenswaarden_TP <- list(
  "Aw-om" = 0.04, 
  "Cb" = 0.04, 
  "Czb" = 0.03, 
  "Zm" = 0.03, 
  "Zs" = 0.03
)

plots_TP <- generate_multiple_plots(reeks_2022_2024, "TP", grenswaarden_TP, "Totale fosfor (mg P/l)")
walk2(plots_TP, names(plots_TP),
      ~ggsave(filename = paste0("./exports/TP/", .y, "_", "TP", ".png"), plot = .x, width = 10, height = 6))

# SO4 - Sulfaat
grenswaarden_SO4 <- list(
  "Aw-om" = 100, 
  "Cb" = 50, 
  "Czb" = 40, 
  "Zm" = 15, 
  "Zs" = 15
)

plots_SO4 <- generate_multiple_plots(reeks_2022_2024, "SO4", grenswaarden_SO4, "Sulfaat (mg/l)")
walk2(plots_SO4, names(plots_SO4),
      ~ggsave(filename = paste0("./exports/SO4/", .y, "_", "SO4", ".png"), plot = .x, width = 10, height = 6))

# Anorganische stikstof
grenswaarden_Nanorg <- list(
  "Aw-om" = 0.14, 
  "Cb" = 0.14, 
  "Czb" = 0.14, 
  "Zm" = 0.14, 
  "Zs" = 0.14
)

plots_N_anorg <- generate_multiple_plots_N_anorg(reeks_2022_2024, "N_anorg", grenswaarden_Nanorg, "Anorganische stikstof (mg N/l)")
walk2(plots_N_anorg, names(plots_N_anorg),
      ~ggsave(filename = paste0("./exports/N_anorg/", .y, "_", "N_anorg", ".png"), plot = .x, width = 10, height = 6))

# Absorptie 440 (geen norm)
plots_abs <- generate_multiple_plots_nohline(reeks_2022_2024, "absorptie_440", "Absorptie (ABS)")
walk2(plots_abs, names(plots_abs),
      ~ggsave(filename = paste0("./exports/absorptie/", .y, "_", "abs", ".png"), plot = .x, width = 10, height = 6))

# Alkaliniteit
plots_alk <- generate_multiple_plots_nohline(reeks_2022_2024, "alkaliniteit", "Alkaliniteit (meq/l)")
walk2(plots_alk, names(plots_alk),
      ~ggsave(filename = paste0("./exports/alkaliniteit/", .y, "_", "abs", ".png"), plot = .x, width = 10, height = 6))

# Fosfaat - fosfor PO4_P
plots_PO4_P <- generate_multiple_plots_nohline(reeks_2022_2024, "PO4_P", "PO4-P (mg P/l)")
walk2(plots_PO4_P, names(plots_PO4_P),
      ~ggsave(filename = paste0("./exports/PO4_P/", .y, "_", "PO4_P", ".png"), plot = .x, width = 10, height = 6))

# ZS105_550
plots_ZS105_550 <- generate_multiple_plots_2_nohline(reeks_2022_2024, "ZS_105", "ZS_550", "Zwevende stof (mg/l)")
walk2(plots_ZS105_550, names(plots_ZS105_550),
      ~ggsave(filename = paste0("./exports/ZS105_550/", .y, "_", "ZS105_550", ".png"), plot = .x, width = 10, height = 6))

# Natrium - Na
grenswaarden_Na <- list(
  "Aw-om" = 17, 
  "Cb" = 17, 
  "Czb" = 17, 
  "Zm" = 17, 
  "Zs" = 17
)

plots_Na <- generate_multiple_plots(reeks_2022_2024, "Na", grenswaarden_Na, "Natrium-concentratie (mg/l)")
walk2(plots_Na, names(plots_Na),
      ~ggsave(filename = paste0("./exports/Natrium/", .y, "_", "Na", ".png"), plot = .x, width = 10, height = 6))

# Kalium - K
plots_K <- generate_multiple_plots_nohline(reeks_2022_2024, "K", "Kalium-concentratie (mg/l)")
walk2(plots_K, names(plots_K),
      ~ggsave(filename = paste0("./exports/Kalium/", .y, "_", "K", ".png"), plot = .x, width = 10, height = 6))

# Magnesium - Mg
plots_Mg <- generate_multiple_plots_nohline(reeks_2022_2024, "Mg", "Magnesium-concentratie (mg/l)")
walk2(plots_Mg, names(plots_Mg),
      ~ggsave(filename = paste0("./exports/Magnesium/", .y, "_", "Mg", ".png"), plot = .x, width = 10, height = 6))

# Ijzer - Fe
plots_Fe <- generate_multiple_plots_nohline(reeks_2022_2024, "Fe", "Ijzer-concentratie (mg/l)")
walk2(plots_Fe, names(plots_Fe),
      ~ggsave(filename = paste0("./exports/Ijzer/", .y, "_", "Fe", ".png"), plot = .x, width = 10, height = 6))

# Aluminium - Al
plots_Al <- generate_multiple_plots_nohline(reeks_2022_2024, "Al", "Aluminium-concentratie (mg/l)")
walk2(plots_Al, names(plots_Al),
      ~ggsave(filename = paste0("./exports/Aluminium/", .y, "_", "Al", ".png"), plot = .x, width = 10, height = 6))

# Calcium - Ca
plots_Ca <- generate_multiple_plots_nohline(reeks_2022_2024, "Ca", "Calcium-concentratie (mg/l)")
walk2(plots_Ca, names(plots_Ca),
      ~ggsave(filename = paste0("./exports/Calcium/", .y, "_", "Ca", ".png"), plot = .x, width = 10, height = 6))

# Silicium - Si
plots_Si <- generate_multiple_plots_nohline(reeks_2022_2024, "Si", "Silicium-concentratie (mg/l)")
walk2(plots_Si, names(plots_Si),
      ~ggsave(filename = paste0("./exports/Silicium/", .y, "_", "Si", ".png"), plot = .x, width = 10, height = 6))

# Organische koolstof - NPOC
plots_NPOC <- generate_multiple_plots_nohline(reeks_2022_2024, "NPOC", "Organische koolstof NPOC (mg/l)")
walk2(plots_NPOC, names(plots_NPOC),
      ~ggsave(filename = paste0("./exports/NPOC/", .y, "_", "NPOC", ".png"), plot = .x, width = 10, height = 6))


```

## aparte code voor zuurtegraad (onder en bovengrenzen - 2 horizontale lijnen)
```{r}
generate_plot_pH <- function(codeplas_value, aqua_component, watertype_thresholds, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent == aqua_component & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data$watertype)
  
  # Check if watertype exists in the thresholds and get min/max values
  if (watertype %in% names(watertype_thresholds)) {
    threshold_min <- watertype_thresholds[[watertype]]$min
    threshold_max <- watertype_thresholds[[watertype]]$max
  } else {
    threshold_min <- NA
    threshold_max <- NA
  }
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
  
  # Add threshold lines only if they are not NA
  if (!is.na(threshold_min)) {
    plot <- plot + geom_hline(yintercept = threshold_min, linetype = "dashed", color = "black", size = 1)
  }
  if (!is.na(threshold_max)) {
    plot <- plot + geom_hline(yintercept = threshold_max, linetype = "dashed", color = "black", size = 1)
  }
  
  return(plot)
}

generate_multiple_plots_pH <- function(codeplas_values, aqua_component, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_pH(.x, aqua_component, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# 2020
generate_plot_2020_pH <- function(codeplas_value, aqua_component, watertype_thresholds, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent == aqua_component & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  watertype <- unique(filtered_data$watertype)
  
  # Check if watertype exists in the thresholds and get min/max values
  if (watertype %in% names(watertype_thresholds)) {
    threshold_min <- watertype_thresholds[[watertype]]$min
    threshold_max <- watertype_thresholds[[watertype]]$max
  } else {
    threshold_min <- NA
    threshold_max <- NA
  }
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    labs(y = y_axis_label) +
  theme(
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    axis.title.x = element_blank()
  )
  
  # Add threshold lines only if they are not NA
  if (!is.na(threshold_min)) {
    plot <- plot + geom_hline(yintercept = threshold_min, linetype = "dashed", color = "black", size = 1)
  }
  if (!is.na(threshold_max)) {
    plot <- plot + geom_hline(yintercept = threshold_max, linetype = "dashed", color = "black", size = 1)
  }
  
  return(plot)
}

generate_multiple_plots_2020_pH <- function(codeplas_values, aqua_component, watertype_thresholds, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020_pH(.x, aqua_component, watertype_thresholds, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# pH thresholds
grenswaarden_pH <- list(
  "Aw-om" = list(min = 6.5, max = 8.5),
  "Cb" = list(min = 5.5, max = 7.5),
  "Czb" = list(min = 5.5, max = 7.5),
  "Zm" = list(min = 4.5, max = 6.5),
  "Zs" = list(min = 4.5, max = 6.5)
)

plots_pH <- generate_multiple_plots_pH(reeks_2022_2024, "pH_veld", grenswaarden_pH, "pH")
walk2(plots_pH, names(plots_pH),
      ~ggsave(filename = paste0("./exports/pH/", .y, "_", "pH", ".png"), plot = .x, width = 10, height = 6))

plots_pH_2020 <- generate_multiple_plots_2020_pH(reeks_2020, "pH_veld", grenswaarden_pH, "pH")
walk2(plots_pH_2020, names(plots_pH_2020),
      ~ggsave(filename = paste0("./exports/pH2020/", .y, "_", "pH2020", ".png"), plot = .x, width = 10, height = 6))

```

## aparte code voor WD en SD (2 variabelen in 1 plot)
```{r}
# waterdiepte en secchi-diepte
grenswaarden_SD <- list(
  "Aw-om" = 1.8, 
  "Cb" = 0.9, 
  "Czb" = 0.9, 
  "Zm" = 0.9, 
  "Zs" = 0.9
)

plots_SD_WD <- generate_multiple_plots_2(reeks_2022_2024, "SD_veld", "WD_veld", grenswaarden_SD, "Meetwaarde (m)")
walk2(plots_SD_WD, names(plots_SD_WD),
      ~ggsave(filename = paste0("./exports/SD_WD/", .y, "_", "SD_WD", ".png"), plot = .x, width = 10, height = 6))

plot_SD_WD_2020 <- generate_multiple_plots_2020_2(reeks_2020, "SD_veld", "WD_veld", grenswaarden_SD, "Meetwaarde (m)")
walk2(plot_SD_WD_2020, names(plot_SD_WD_2020),
      ~ggsave(filename = paste0("./exports/SD_WD2020/", .y, "_", "SD_WD2020", ".png"), plot = .x, width = 10, height = 6))

# zwevende stof 105 en 550
grenswaarden_ZS105 <- list(
  "Aw-om" = 2.5, 
  "Cb" = 2.5, 
  "Czb" = 4, 
  "Zm" = 4, 
  "Zs" = 4
)

plots_ZS105 <- generate_multiple_plots_2_nohline(reeks_2022_2024, "ZS_105", "ZS_550", "Zwevende stof (mg/l)")
walk2(plots_ZS105, names(plots_ZS105),
      ~ggsave(filename = paste0("./exports/ZS_105_550/", .y, "_", "ZS105_550", ".png"), plot = .x, width = 10, height = 6))
```

## aparte code N_anorganisch (NH4_N + NO3_N + NO2_N)
```{r}
generate_plot_Nanorg <- function(codeplas_value, aqua_components, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent %in% aqua_components & meetreeks == "2022-2024" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, fill = AquaComponent)) +
    geom_area(position = "identity", alpha = 0.6, color = "black", size = 0.5) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    scale_fill_brewer(palette = "Set2") +
    labs(y = y_axis_label) +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.position = "bottom",
      legend.title = element_blank(),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_Nanorg <- function(codeplas_values, aqua_components, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_Nanorg(.x, aqua_components, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# voor <2020
generate_plot_2020_Nanorg <- function(codeplas_value, aqua_components, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent %in% aqua_components & meetreeks == "<2020" & codeplas == codeplas_value)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  # If y_label is not provided, use "ResultCalc" as default
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, fill = AquaComponent)) +
    geom_area(position = "identity", alpha = 0.6, color = "black", size = 0.5) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    scale_fill_brewer(palette = "Set2") +
    labs(y = y_axis_label) +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.position = "bottom",
      legend.title = element_blank(),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_2020_Nanorg <- function(codeplas_values, aqua_components, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020_Nanorg(.x, aqua_components, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# met log-transformatie
generate_plot_Nanorglog <- function(codeplas_value, aqua_components, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent %in% aqua_components & meetreeks == "2022-2024" & codeplas == codeplas_value) %>%
    mutate(log_ResultCalc = log10(pmax(ResultCalc, 1e-10)))  # Avoid log(0)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  y_axis_label <- if(is.null(y_label)) "log10(ResultCalc)" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = log_ResultCalc, fill = AquaComponent, color = AquaComponent)) +
    geom_ribbon(aes(ymin = min(log_ResultCalc), ymax = log_ResultCalc), alpha = 0.6) +
    geom_line(size = 0.5) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10),
                       labels = function(x) sprintf("10^%.0f", x),
                       limits = c(NA, NA)) +  # Allow ggplot to set appropriate limits
    scale_fill_brewer(palette = "Set2") +
    scale_color_brewer(palette = "Set2") +
    labs(y = y_axis_label) +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.position = "bottom",
      legend.title = element_blank(),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_Nanorglog <- function(codeplas_values, aqua_components, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_Nanorglog(.x, aqua_components, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# voor < 2020 logaritmisch
generate_plot_2020_Nanorglog <- function(codeplas_value, aqua_components, y_label = NULL) {
  filtered_data <- data_TVG %>%
    filter(AquaComponent %in% aqua_components & meetreeks == "<2020" & codeplas == codeplas_value) %>%
    mutate(log_ResultCalc = log10(pmax(ResultCalc, 1e-10)))  # Avoid log(0)
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  y_axis_label <- if(is.null(y_label)) "log10(ResultCalc)" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = log_ResultCalc, fill = AquaComponent, color = AquaComponent)) +
    geom_ribbon(aes(ymin = min(log_ResultCalc), ymax = log_ResultCalc), alpha = 0.6) +
    geom_line(size = 0.5) +
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10),
                       labels = function(x) sprintf("10^%.0f", x),
                       limits = c(NA, NA)) +  # Allow ggplot to set appropriate limits
    scale_fill_brewer(palette = "Set2") +
    scale_color_brewer(palette = "Set2") +
    labs(y = y_axis_label) +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.position = "bottom",
      legend.title = element_blank(),
      axis.title.x = element_blank()
    )
  
  return(plot)
}



generate_multiple_plots_2020_Nanorglog <- function(codeplas_values, aqua_components, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_2020_Nanorglog(.x, aqua_components, y_label))
  names(plots) <- codeplas_values
  return(plots)
}


# 2022-2024
plots_N_anorg <- generate_multiple_plots_Nanorg(reeks_2022_2024, c("NH4_N", "NO3_N", "NO2_N"), "mg N/l")
walk2(plots_N_anorg, names(plots_N_anorg),
      ~ggsave(filename = paste0("./exports/NH4_N+NO3_N+NO2_N/", .y, "_", "N_anorg", ".png"), plot = .x, width = 10, height = 6))

plots_N_anorg_log <- generate_multiple_plots_Nanorglog(reeks_2022_2024, c("NH4_N", "NO3_N", "NO2_N"), "log10 (mg N/l)")
walk2(plots_N_anorg_log, names(plots_N_anorg_log),
      ~ggsave(filename = paste0("./exports/NH4_N+NO3_N+NO2_N_log/", .y, "_", "N_anorg_log", ".png"), plot = .x, width = 10, height = 6))

## Met N_anorg + componenten
plots_N_anorg_comp <- generate_multiple_plots_Nanorg(reeks_2022_2024, c("NH4_N", "NO3_N", "NO2_N", "N_anorg"), "mg N/l")
walk2(plots_N_anorg_comp, names(plots_N_anorg_comp),
      ~ggsave(filename = paste0("./exports/Nanorg_componenten/", .y, "_", "Nanorg_componenten", ".png"), plot = .x, width = 10, height = 6))

plots_N_anorg_comp_log <- generate_multiple_plots_Nanorglog(reeks_2022_2024, c("NH4_N", "NO3_N", "NO2_N", "N_anorg"), "mg N/l")
walk2(plots_N_anorg_comp_log, names(plots_N_anorg_comp_log),
      ~ggsave(filename = paste0("./exports/Nanorg_componentenlog/", .y, "_", "Nanorg_componentenlog", ".png"), plot = .x, width = 10, height = 6))


# < 2020
plots_N_anorg_2020 <- generate_multiple_plots_2020_Nanorg(reeks_2020, c("NH4_N", "NO3_N", "NO2_N"), "mg N/l")
walk2(plots_N_anorg_2020, names(plots_N_anorg_2020),
      ~ggsave(filename = paste0("./exports/NH4_N+NO3_N+NO2_N2020/", .y, "_", "N_anorg2020", ".png"), plot = .x, width = 10, height = 6))

plots_N_anorg_log_2020 <- generate_multiple_plots_2020_Nanorglog(reeks_2020, c("NH4_N", "NO3_N", "NO2_N"), "log10 (mg N/l)")
walk2(plots_N_anorg_log_2020, names(plots_N_anorg_log_2020),
      ~ggsave(filename = paste0("./exports/NH4_N+NO3_N+NO2_N_log2020/", .y, "_", "N_anorg_log2020", ".png"), plot = .x, width = 10, height = 6))

## Met N_anorg + componenten
plots_N_anorg_2020_comp <- generate_multiple_plots_2020_Nanorg(reeks_2020, c("NH4_N", "NO3_N", "NO2_N", "N_anorg"), "mg N/l")
walk2(plots_N_anorg_2020_comp, names(plots_N_anorg_2020_comp),
      ~ggsave(filename = paste0("./exports/Nanorg_componenten2020/", .y, "_", "Nanorg_componenten2020", ".png"), plot = .x, width = 10, height = 6))

plots_N_anorg_2020_comp_log <- generate_multiple_plots_2020_Nanorglog(reeks_2020, c("NH4_N", "NO3_N", "NO2_N", "N_anorg"), "mg N/l")
walk2(plots_N_anorg_2020_comp_log, names(plots_N_anorg_2020_comp_log),
      ~ggsave(filename = paste0("./exports/Nanorg_componentenlog2020/", .y, "_", "Nanorg_componentenlog2020", ".png"), plot = .x, width = 10, height = 6))
```

## aparte code N_organisch (TN - Nanorg)
```{r}
generate_plot_Norg <- function(codeplas_value, aqua_components, y_label = NULL) {
  filtered_data <- data_met_N_anorg %>%
    filter(AquaComponent %in% aqua_components & meetreeks == "2022-2024" & codeplas == codeplas_value) %>%
    mutate(AquaComponent = factor(AquaComponent, levels = c("TN", "N_anorg")))  # Set order
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, fill = AquaComponent)) +
    geom_area(position = "identity", alpha = 0.6) +
    geom_line(aes(color = AquaComponent), size = 1) +  # Add lines
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    scale_fill_manual(values = c("TN" = "#66C2A5", "N_anorg" = "#FC8D62")) +  # Custom colors
    scale_color_manual(values = c("TN" = "#66C2A5", "N_anorg" = "#FC8D62")) +  # Match line colors
    labs(y = y_axis_label) +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.position = "bottom",
      legend.title = element_blank(),
      axis.title.x = element_blank()
    )
  
  return(plot)
}

generate_multiple_plots_Norg <- function(codeplas_values, aqua_components, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_Norg(.x, aqua_components, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

#<2020
generate_plot_Norg_2020 <- function(codeplas_value, aqua_components, y_label = NULL) {
  filtered_data <- data_met_N_anorg %>%
    filter(AquaComponent %in% aqua_components & meetreeks == "<2020" & codeplas == codeplas_value) %>%
    mutate(AquaComponent = factor(AquaComponent, levels = c("TN", "N_anorg")))  # Set order
  
  n_results <- nrow(filtered_data)
  interval <- if(n_results > 12) "2 months" else "1 month"
  
  y_axis_label <- if(is.null(y_label)) "ResultCalc" else y_label
  
  plot <- filtered_data %>%
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, fill = AquaComponent)) +
    geom_area(position = "identity", alpha = 0.6) +
    geom_line(aes(color = AquaComponent), size = 1) +  # Add lines
    scale_x_date(date_breaks = interval, date_labels = "%m/%y") +
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    scale_fill_manual(values = c("TN" = "#66C2A5", "N_anorg" = "#FC8D62")) +  # Custom colors
    scale_color_manual(values = c("TN" = "#66C2A5", "N_anorg" = "#FC8D62")) +  # Match line colors
    labs(y = y_axis_label) +
    theme(
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14),
      legend.position = "bottom",
      legend.title = element_blank(),
      
    )
  
  return(plot)
}

generate_multiple_plots_Norg_2020 <- function(codeplas_values, aqua_components, y_label = NULL) {
  plots <- map(codeplas_values, ~generate_plot_Norg_2020(.x, aqua_components, y_label))
  names(plots) <- codeplas_values
  return(plots)
}

# 2022-2024
plots_N_org <- generate_multiple_plots_Norg(reeks_2022_2024, c("TN", "N_anorg"), "mg N/l")
walk2(plots_N_org, names(plots_N_org),
      ~ggsave(filename = paste0("./exports/N_org/", .y, "_", "N_org", ".png"), plot = .x, width = 10, height = 6))

# <2020
plots_N_org_2020 <- generate_multiple_plots_Norg_2020(reeks_2020, c("TN", "N_anorg"), "mg N/l")
walk2(plots_N_org_2020, names(plots_N_org_2020),
      ~ggsave(filename = paste0("./exports/N_org2020/", .y, "_", "N_org2020", ".png"), plot = .x, width = 10, height = 6))

```


# EXPORTS VOOR TOETSING MKN
## Zuurtegraad
```{r}
data_TVG %>%
  filter(AquaComponent %in% "pH_veld") %>%
  group_by(codeplas) %>%
  summarise(pH_min = min(ResultCalc, na.rm = TRUE),
            pH_max = max(ResultCalc, na.rm = TRUE),
            pH_bereik = paste(min(ResultCalc, na.rm = TRUE), "-", max(ResultCalc, na.rm = TRUE))) %>%
  write.csv2(file = "./exports/pH.csv")

data_TVG %>%
  filter(AquaComponent %in% "pH_veld" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(pH_min = min(ResultCalc, na.rm = TRUE),
            pH_max = max(ResultCalc, na.rm = TRUE),
            pH_bereik = paste(min(ResultCalc, na.rm = TRUE), "-", max(ResultCalc, na.rm = TRUE))) %>%
  write.csv2(file = "./exports/pH2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "pH_veld" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  group_by(codeplas) %>%
  summarise(pH_min = min(ResultCalc, na.rm = TRUE),
            pH_max = max(ResultCalc, na.rm = TRUE),
            pH_bereik = paste(min(ResultCalc, na.rm = TRUE), "-", max(ResultCalc, na.rm = TRUE))) %>%
  write.csv2(file = "./exports/pH22_23.csv")
```

## Helderheid
```{r}
# Secchi-diepte (SD_veld)
data_TVG %>%
  filter(AquaComponent %in% "SD_veld" & meetreeks == "2022-2024") %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(SD_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/SD_zhj_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "SD_veld" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(SD_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/SD_zhj_2022-23.csv")

# Waterdiepte (WD_diepte)
data_TVG %>%
  filter(AquaComponent %in% "WD_veld" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(WD_gem = mean(ResultCalc, na.rm = TRUE),
            WD_max = max(ResultCalc, na.rm = TRUE),
            WD_min = min(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/WD2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "WD_veld" & meetreeks == "2022-2024") %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(SD_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/WD_zhj_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "WD_veld" & meetreeks == "2022-2023") %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(SD_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/WD_zhj_2022-23.csv")

# Zwevende stof (ZS_105 en ZS_550)
data_TVG %>%
  filter(AquaComponent %in% "ZS_105" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(ZS105_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/ZS105_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "ZS_105" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(ZS105_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/ZS105_2022-23.csv")

data_TVG %>%
  filter(AquaComponent %in% "ZS_550" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(ZS550_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/ZS550_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "ZS_550" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(ZS550_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/ZS550_2022-23.csv")

data_TVG %>%
  filter(AquaComponent %in% "ZS_105") %>%
  group_by(codeplas) %>%
  summarise(ZS105_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/ZS105_gem.csv")

# Zwevende stof 105 boxplot
data_TVG %>%
  filter(AquaComponent == "ZS_105" & meetreeks == "2022-2024") %>%
  ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
  geom_boxplot() +
  xlab("Zwevende stof (mg/l 105¬∞C)") +
  facet_grid(watertype ~ ., scales = "free", space = "free_y") +
  scale_x_continuous(breaks = pretty_breaks(n = 10))

# Zwevende stof 550 boxplot
data_TVG %>%
  filter(AquaComponent == "ZS_550" & meetreeks == "2022-2024") %>%
  ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
  geom_boxplot() +
  xlab("Zwevende stof (mg/l 550¬∞C)") +
  facet_grid(watertype ~ ., scales = "free", space = "free_y") +
  scale_x_continuous(breaks = pretty_breaks(n = 10))

# Humuszuren (absorptie_440)
data_TVG %>%
  filter(AquaComponent %in% "absorptie_440") %>%
  group_by(codeplas) %>%
  summarise(ABS440_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/abs440_gem.csv")

data_TVG %>%
  filter(AquaComponent %in% "absorptie_440" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(abs_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/abs_zhj_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "absorptie_440" & meetreeks == "2022-2023" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(abs_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/abs_zhj_2022-23.csv")

# absorptie 440 nm
data_TVG %>%
  filter(AquaComponent == "absorptie_440" & meetreeks == "2022-2024") %>%
  ggplot(aes(x = ResultCalc, y = codeplas, colour = watertype)) +
  geom_boxplot() +
  xlab("Absorptie 440 nm (ABS)") +
  facet_grid(watertype ~ ., scales = "free", space = "free_y") +
  scale_x_continuous(breaks = pretty_breaks(n = 10))

# chlorofyl-a
data_TVG %>%
  filter(AquaComponent %in% "chl_a" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(chla_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/chl_a_zhj_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "chl_a" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(chla_zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/chl_a_zhj_2022-23.csv")

```


## Zuurstofcondities
```{r}
# concentratie
data_TVG %>%
  filter(AquaComponent %in% "O2_veld" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(O2_10p = quantile(ResultCalc,probs = 0.1, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/O2_conc_2224.csv")
data_TVG %>%
  filter(AquaComponent %in% "O2_veld" & codeplas %in% reeks_2022_2023 & meetreeks == "2022-2023") %>%
  group_by(codeplas) %>%
  summarise(O2_10p = quantile(ResultCalc,probs = 0.1, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/O2_conc_2022-23.csv")

# verzadiging
data_TVG %>%
  filter(AquaComponent %in% "O2verz"& meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(O2_verz_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/O2_verz_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "O2verz" & codeplas %in% reeks_2022_2023 & meetreeks == "2022-2023") %>%
  group_by(codeplas) %>%
  summarise(O2_verz_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/O2_verz_2022-23.csv")

```

## Temperatuur
```{r}
data_TVG %>%
  filter(AquaComponent %in% "T_veld") %>%
  group_by(codeplas, meetreeks) %>%
  summarise(Temp_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Temp_veld.csv")

data_TVG %>%
  filter(AquaComponent %in% "T_veld" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Temp_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Temp_veld2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "T_veld" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  group_by(codeplas) %>%
  summarise(Temp_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Temp_veld22_23.csv")

```

## Alkaliniteit, Natrium, Silicium, Calcium, Kalium, Magnesium
```{r}
# alkaliniteit
data_TVG %>%
  filter(AquaComponent %in% "alkaliniteit" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Alk_mean = mean(ResultCalc),
            Alk_min = min(ResultCalc, na.rm = TRUE),
            Alk_max = max(ResultCalc, na.rm = TRUE),
            Alk_bereik = paste(min(ResultCalc, na.rm = TRUE), "-", max(ResultCalc, na.rm = TRUE))) %>%
  write.csv2(file = "./exports/Alka_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "alkaliniteit" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  group_by(codeplas) %>%
  summarise(Alk_mean = mean(ResultCalc),
            Alk_min = min(ResultCalc, na.rm = TRUE),
            Alk_max = max(ResultCalc, na.rm = TRUE),
            Alk_bereik = paste(min(ResultCalc, na.rm = TRUE), "-", max(ResultCalc, na.rm = TRUE))) %>%
  write.csv2(file = "./exports/Alka_22-23.csv")

# Silicium
data_TVG %>%
  filter(AquaComponent %in% "Si" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Si_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Si_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Si" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(Si_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Si_22-23.csv")


# Calcium
data_TVG %>%
  filter(AquaComponent %in% "Ca" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Ca_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Ca_2224.csv")
data_TVG %>%
  filter(AquaComponent %in% "Ca" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(Ca_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Ca_22-23.csv")

## Calcium max zomer
data_TVG %>%
  filter(AquaComponent %in% "Ca" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(Ca_maxzomer = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Ca_maxzomer2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Ca" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023 & seizoen == "zomer")  %>%
  group_by(codeplas) %>%
  summarise(Ca_maxzomer = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Ca_maxzomer22-23.csv")

# Kalium
data_TVG %>%
  filter(AquaComponent %in% "K" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(K_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/K_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "K" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(K_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/K_22-23.csv")


# Magnesium
data_TVG %>%
  filter(AquaComponent %in% "Mg" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Mg_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Mg_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Mg" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(Mg_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Mg_22-23.csv")

```


## Zoutparameters
```{r}
# Geleidbaarheid
data_TVG %>%
  filter(AquaComponent %in% "EGV25_veld" & meetreeks == "2022-2024")  %>%
  group_by(codeplas) %>%
  summarise(EGV_90p = quantile(ResultCalc, probs = 0.9, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/EGV2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "EGV25_veld" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(EGV_90p = quantile(ResultCalc, probs = 0.9, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/EGV2022-23.csv")

# Sulfaat (SO4)
data_TVG %>%
  filter(AquaComponent %in% "SO4" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(SO4_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/SO4_2224.csv")
data_TVG %>%
  filter(AquaComponent %in% "SO4" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(SO4_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/SO4_22-23.csv")


# Natrium
data_TVG %>%
  filter(AquaComponent %in% "Na" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Na_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Na_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Na" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  group_by(codeplas) %>%
  summarise(Na_gem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Na_22-23.csv")

## Natrium max zomer
data_TVG %>%
  filter(AquaComponent %in% "Na" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(Na_maxzhj = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Na_maxzomer2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Na" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(Na_maxzomer = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Na_maxzomer22-23.csv")

data_TVG %>%
  filter(AquaComponent %in% "Na") %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(Na_max_zomer = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Na_max_zomer.csv")

# Chloride
data_TVG %>%
  filter(AquaComponent %in% "Cl" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(Cl_max = max(ResultCalc, na.rm = TRUE),
            Cl_90p = quantile(ResultCalc, probs = 0.9, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Cl_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Cl" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  group_by(codeplas) %>%
  summarise(Cl_max = max(ResultCalc, na.rm = TRUE),
            Cl_90p = quantile(ResultCalc, probs = 0.9, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Cl_22-23.csv")

## Chloride max zomer
data_TVG %>%
  filter(AquaComponent %in% "Cl" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(Cl_maxzhj = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Cl_maxzomer2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "Cl" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023)  %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(Cl_maxzomer = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Cl_maxzomer22-23.csv")

# saliniteit
data_TVG %>%
  filter(AquaComponent %in% "sal_veld") %>%
  group_by(codeplas) %>%
  summarise(sal_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/Sal.csv")
```


## Nutri√´nten
```{r}
# Totale Stikstof - TN & Totale Fosfor - TP
data_TVG %>%
  filter(AquaComponent %in% c("TN", "TP")) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas, AquaComponent) %>%
  summarise(zhjgem = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/TN_TP.csv")

data_TVG %>%
  filter(AquaComponent %in% c("TN", "TP") & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas, AquaComponent) %>%
  summarise(zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/TN_TP_zhj_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% c("TN", "TP") & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas, AquaComponent) %>%
  summarise(zhjgem = mean(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/TN_TP_zhj_22-23.csv")

# NO3-N
data_TVG %>%
  filter(AquaComponent %in% "NO3_N" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(NO3_N_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/NO3_N_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "NO3_N" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(NO3_N_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/NO3_N_22-23.csv")

# NO2-N
data_TVG %>%
  filter(AquaComponent %in% "NO2_N" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(NO2_N_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/NO2_N_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "NO2_N" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(NO2_N_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/NO2_N_22-23.csv")

## Van Calster NO2_N gemiddelde & maximum
data_TVG %>%
  filter(AquaComponent %in% "NO2_N" & meetreeks == "2022-2024") %>%
  group_by(codeplas) %>%
  summarise(NO2_Ngem = mean(ResultCalc),
            NO2_Nmax = max(ResultCalc)) %>%
  write.csv2(file = "./exports/NO2_Ngemmax_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "NO2_N" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  group_by(codeplas) %>%
  summarise(NO2_Ngem = mean(ResultCalc),
            NO2_Nmax = max(ResultCalc)) %>%
  write.csv2(file = "./exports/NO2_Ngemmax_22-23.csv")

# NH4-N
data_TVG %>%
  filter(AquaComponent %in% "NH4_N" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(NH4_N_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/NH4_N_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "NH4_N" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(NH4_N_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/NH4_N_22-23.csv")

# PO4-P
data_TVG %>%
  filter(AquaComponent %in% "PO4_P" & meetreeks == "2022-2024" & seizoen == "zomer") %>%
  group_by(codeplas) %>%
  summarise(PO4_P_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/PO4_P_2224.csv")

data_TVG %>%
  filter(AquaComponent %in% "PO4_P" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(PO4_P_zhj = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/PO4_P_22-23.csv")

```

## Anorganische en organische stikstof

```{r}
# zomerhalfjaargemiddelde
data_met_N_anorg %>%
  filter(AquaComponent %in% "N_anorg") %>%
  mutate(month = format(FieldSamplingDate, "%m")) %>%
  filter(month %in% c("04", "05", "06", "07", "08", "09")) %>%
  group_by(codeplas) %>%
  summarise(zhjgem = mean(ResultCalc)) %>%
  write.csv2(file = "./exports/N_anorg_zhj.csv")

# maximum (van Calster)
data_met_N_anorg %>%
  filter(AquaComponent %in% "N_anorg" & meetreeks == "2022-2024" ) %>%
  group_by(codeplas) %>%
  summarise(N_anorg_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/N_anorg_max2224.csv")

data_met_N_anorg %>%
  filter(AquaComponent %in% "N_anorg" & meetreeks == "2022-2023" & codeplas %in% reeks_2022_2023) %>%
  group_by(codeplas) %>%
  summarise(N_anorg_max = max(ResultCalc, na.rm = TRUE)) %>%
  write.csv2(file = "./exports/N_anorg_max2022-23.csv")
```


# MAUCHA

## originele code Maucha (per plas figuur opslaan)
```{r}
maucha <- function(x, col = NULL,
                   labels = TRUE, labels.col = 1,
                   polygon = FALSE, polygon.col = 1,
                   main = NULL, ...){
  
  if(is.null(col)){
    col <- c("#54c7fd", "#ffcd00", "#ff9600", "#ff2851",
             "#0076fe", "#41cd58", "#ff3823", "#8f8e94")
  }
  col <- rep_len(col, length.out = 8)
  polygon.col <- rep_len(polygon.col, length.out = 8)
  
  if(is.vector(x)){
    n.plot <- 1
    x.all <- t(as.matrix(x))
  } else {
    x.all <- as.matrix(x)
    n.plot <- nrow(x.all)
    if(is.null(main)){
      main <- row.names(x.all)
    }
  }
  
  par.mar.0 <- par("mar")
  par.mfrow.0 <- par("mfrow")
  par(mfrow = c(.dimMosaic(n.plot)[1], .dimMosaic(n.plot)[2]),
      mar = c(2, 0, 2, 0))
  
  for(j in 1:n.plot){
    
    x <- x.all[j, ]
    
    x[1] <- (x[1] * 1) / 39.0983
    x[2] <- (x[2] * 1) / 22.9898
    x[3] <- (x[3] * 2) / 40.0780
    x[4] <- (x[4] * 2) / 24.3050
    x[5] <- (x[5] * 2) / 96.0626
    x[6] <- (x[6] * 1) / 35.4530
    x[7] <- (x[7] * 1) / 61.0168
    x[8] <- (x[8] * 2) / 60.0089
    
    x[1:4] <- x[1:4] / sum(x[1:4]) * 100
    x[5:8] <- x[5:8] / sum(x[5:8]) * 100
    
    A  <- sum(x)
    R <- sqrt(((A / 16) * 2 / sin(22.5 * pi / 180)))
    a <- x / (R * sin(22.5 * pi / 180))
    
    
    coord.x <- matrix(NA, nrow = 5, ncol = 8)
    coord.y <- matrix(NA, nrow = 5, ncol = 8)
    coord.x[1, ] <- coord.x[5, ] <- rep(0, 8)
    coord.y[1, ] <- coord.y[5, ] <- rep(0, 8)
    coord.x[2, ] <- cos(seq(90, -225, -45) * pi / 180) * R
    coord.y[2, ] <- sin(seq(90, -225, -45) * pi / 180) * R
    coord.x[3, ] <- cos(seq(67.5, -247.5, -45) * pi / 180) * a
    coord.y[3, ] <- sin(seq(67.5, -247.5, -45) * pi / 180) * a
    coord.x[4, ] <- cos(seq(45, -270, -45) * pi / 180) * R
    coord.y[4, ] <- sin(seq(45, -270, -45) * pi / 180) * R
    
    
    if(polygon | labels){
      coord.poly.x <- coord.x
      coord.poly.x[3, ] <- cos(seq(67.5, -247.5, -45) * pi / 180) * R
      coord.poly.y <- coord.y
      coord.poly.y[3, ] <- sin(seq(67.5, -247.5, -45) * pi / 180) * R
    }
    
    if(labels){
      lab <- c("K", "Na", "Ca", "Mg", "SO4", "Cl", "HCO3_OEP", "CO3")
      lab.pos.x <- coord.x[3, ]
      lab.pos.y <- coord.y[3, ]
      lab.pos.x[a < R] <- coord.poly.x[3, a < R]
      lab.pos.y[a < R] <- coord.poly.y[3, a < R]
      lab.pos.x <- lab.pos.x + cos(seq(67.5, -247.5, -45) * pi / 180) * 2
      lab.pos.y <- lab.pos.y + sin(seq(67.5, -247.5, -45) * pi / 180) * 2
    }
    
    
    xlim <- max(abs(c(min(lab.pos.x), max(lab.pos.x))))
    ylim <- max(abs(c(min(lab.pos.y), max(lab.pos.y))))
    plot(0, 0, type = "n", xlim = c(-xlim, xlim), ylim = c(-ylim, ylim),
         xaxt = "n", yaxt = "n", xlab = "", ylab = "", asp = 1, bty = "n", main = main[j], ...)
    
    for(i in 1:8){
      polygon(x = coord.x[, i], y = coord.y[, i], col = col[i], border = NA)
      if(polygon){
        lines(x = coord.poly.x[, i], y = coord.poly.y[, i], col = polygon.col[i])
      }
    }
    
    if(labels){
      text(lab.pos.x, lab.pos.y, lab, col = labels.col)
    }
  }
  par(mar = par.mar.0, mfrow = par.mfrow.0)
}

# Compute a grid for graphical arrangement
.dimMosaic <- function(n.plot){
  x <- floor(sqrt(n.plot))
  y <- floor(sqrt(n.plot))
  if(x * y < n.plot) y <- y + 1
  if(x * y < n.plot) x <- x + 1
  return(c(x, y))
}
```

## Maak dataset met ionen
```{r}
# dataset met ionen (gemiddelde waarde per locatie)
# meetreeks 2022-2024
ionen22_24 <- data_TVG %>%
  filter(AquaComponent %in% c("K", "Na", "Ca", "Mg", "SO4", "Cl", "HCO3_OEP", "CO3") & meetreeks == "2022-2024" & codeplas %in% reeks_2022_2024) %>%
  group_by(AquaComponent, codeplas) %>%
  summarise(gemiddelde = mean(ResultCalc))

# to wide format
ionenwide22_24 <- pivot_wider(ionen22_24, names_from = AquaComponent, values_from = gemiddelde)
ionenwide22_24 <- ionenwide22_24 %>% select(codeplas, K, Na, Ca, Mg, SO4, Cl, HCO3_OEP, CO3)
```


### Maucha-diagram voor alle locaties (gemiddelde per locatie)
```{r}
# converteer kolom met locatiecode naar row.names voor maucha-functie
ionenwide22_24 <- ionenwide22_24 %>% remove_rownames %>% column_to_rownames(var = "codeplas")
maucha(ionenwide22_24)
```

### Maucha-diagram per locatie (figuur per maand)
#### Tijdsreeks 2024 Maak dataset aan voor locatie x
```{r}
# "ANTTUR0299" "ANTTUR0297" "ANTTUR0292" "ANTTUR0282" "ANTRAV0014"
locatie <- "ANTRAV0014"


datamaucha <- data_TVG %>%
  filter(AquaComponent %in% c("K", "Na", "Ca", "Mg", "SO4", "Cl", "HCO3_OEP", "CO3") & codeplas == locatie & meetreeks == "2022-2024") %>%
  group_by(AquaComponent, FieldSamplingDate) %>%
  summarise(gemiddelde = mean(ResultCalc)) %>%
  select(FieldSamplingDate, AquaComponent, gemiddelde)

# to wide format
datamauchawide <- pivot_wider(datamaucha, names_from = AquaComponent, values_from = gemiddelde)
# kolommen in juiste volgorde (! belangrijk voor correct Maucha-diagram)
datamauchawide <- datamauchawide %>%
  select(FieldSamplingDate, K, Na, Ca, Mg, SO4, Cl, HCO3_OEP, CO3)

# converteer kolom met datum staalname naar row.names voor maucha-functie
datamauchawide <- datamauchawide %>% remove_rownames %>% column_to_rownames(var = "FieldSamplingDate")
maucha(datamauchawide)
```

```{r}
# "" "" "" "" "" "" "" "" ""
# "" "" "" "" "" "" "" "" ""
# "" "" "" "" "" "" "" "" ""
# "" "" "" "" "" "" "" "" ""
# "" "" "" "ANTMRK0177"
locatie <- "ANTTUR0296"


datamaucha <- data_TVG %>%
  filter(AquaComponent %in% c("K", "Na", "Ca", "Mg", "SO4", "Cl", "HCO3_OEP", "CO3") & codeplas == locatie & meetreeks == "2022-2023") %>%
  group_by(AquaComponent, FieldSamplingDate) %>%
  summarise(gemiddelde = mean(ResultCalc)) %>%
  select(FieldSamplingDate, AquaComponent, gemiddelde)

# to wide format
datamauchawide <- pivot_wider(datamaucha, names_from = AquaComponent, values_from = gemiddelde)
# kolommen in juiste volgorde (! belangrijk voor correct Maucha-diagram)
datamauchawide <- datamauchawide %>%
  select(FieldSamplingDate, K, Na, Ca, Mg, SO4, Cl, HCO3_OEP, CO3)

# converteer kolom met datum staalname naar row.names voor maucha-functie
datamauchawide <- datamauchawide %>% remove_rownames %>% column_to_rownames(var = "FieldSamplingDate")
maucha(datamauchawide)
```


# IR-EGV
## referentie-punten
```{r}
ref_punten <- data.frame(
      location_ref = c("Li (Angeren)", "At (Witteveen)", "Th (Noordwijk)"),
      Ca_ref = c(115, 0.4, 420),
      Cl_ref = c(11, 3, 19100),
      ec25_ref = c(651, 50.1, 52000), # in ¬µS/cm
      ir_ref = c(.95, .20, .04), # without units (in 0-1)
      name_ref = c("Li", "At", "Th"))
```

## gemiddelde Cl en Ca concentraties per locatie
```{r}
# voor meetreeks 2022-24 (40 locaties)
IREGVdata24 <- data_TVG %>% 
  filter(AquaComponent %in% c("Ca", "Cl", "EGV25_veld") & meetreeks %in% "2022-2024") %>%
  group_by(codeplas, AquaComponent, meetreeks) %>% summarise(gemiddelde = mean(ResultCalc))

## naar wide format (componenten als kolommen)
IREGVwide24 <- pivot_wider(IREGVdata24, names_from = AquaComponent, values_from = gemiddelde)

## bereken en voeg IR toe als kolom
IREGVwide24 <- IREGVwide24 %>%
  mutate(IR = ((Ca*2)/40.078) / (((Ca*2)/40.078) + (Cl/35.453)), name_ref = codeplas)

IREGVwide24 <- IREGVwide24 %>% 
  left_join(data_locaties[,c(2,7)])
```

## plot IR_EGV diagram
```{r}
# per watertype
p1 <- ggplot(ref_punten, aes(x = ec25_ref, y = ir_ref, label = name_ref)) +
  geom_point(size = 2) + 
  scale_x_log10() + 
  xlab("EGV (¬µS/cm)") + 
  ylab("IR (%)") + 
  scale_y_continuous(breaks = seq(0,1, by = 0.1)) + 
  ggtitle("IR-EGV diagram Turnhout\n") + 
  geom_text(hjust = - 0.3, vjust = - 0.3)
p1 + geom_point(data = IREGVwide24, mapping = aes(x = EGV25_veld, y = IR, colour = watertype))

p1 + geom_point(data = IREGVwide24, mapping = aes(x = EGV25_veld, y = IR), colour = "orange2")
```

### plot Ionenratio
```{r}
IREGVwide24 %>%
    ggplot(aes(x = IR, y = codeplas, colour = watertype)) +
    geom_point() +
    labs(title = "Ionenratio (%)\n") +
    ylab("Locatie") + xlab("ratio (%)")

IREGVwide24 %>%
  ggplot(aes(x = IR, y = codeplas, colour = watertype)) +
  geom_point(size = 2) +
  ylab("Locatie") + 
  xlab("Ionenratio (%)") +
  facet_grid(watertype ~ ., scales = "free", space = "free_y") +
  scale_x_continuous(breaks = pretty_breaks(n = 10))
```

