---
title: "TVG Data-Analyse"
author: "Florian Van Hecke"
date: "2024-12-09"
output: html_document
---

# packages laden
```{r setup, results ='hide', eval = TRUE, echo = FALSE, message = FALSE, cache = FALSE, purl = FALSE, warning = FALSE}
library(knitr)
opts_chunk$set(
  echo = FALSE, 
  eval = TRUE,  
  cache = FALSE, 
  autodep = TRUE,
  dpi = 300,
  fig.width = 150 / 25.4,
  fig.height = 100 / 25.4,
  warning = TRUE,
  error = TRUE,
  message = TRUE
)
# Enable inbo r-universe
options(repos = c(
    inbo = 'https://inbo.r-universe.dev',
    CRAN = 'https://cloud.r-project.org'))
library(dplyr)
library(ggplot2)
library(tidyr)
library(tibble)

```

# data inlezen
```{r}
data_locaties <- read.csv(file = "../data/TVG_gemeten_plassen.csv", sep = ";")
data_TVG <- read.csv(file = "../data/FactResultAqua_bewerkt_2024-12-06.csv", sep = ";")
locaties <- data_locaties$codeplas
# gebruik locaties van TVG
data_TVG <- data_TVG %>%
  filter(CODE %in% locaties)
unique(data_TVG$AquaComponent)
data_TVG <- data_TVG[!is.na(data_TVG$AquaComponent),]
```

# voeg ResultCalc toe als kolom voor meetwaarden onder detectielimiet
```{r}
data_TVG <- data_TVG %>%
  mutate(ResultCalc = ifelse(grepl("<", ResultFormatted), 
                             as.numeric(gsub("<", "", ResultFormatted)) / 2, # als operator <, deel waarde door 2
                             as.numeric(gsub(">", "", ResultFormatted)))) # als > of geen operator, neem waarde over
```

# voeg label toe als kolom
```{r}
data_TVG <- data_TVG %>%
  mutate(label = paste0(AquaComponent, " (", AquaUnit, ")"))
```


```{r}
Componenten <- unique(data_TVG$AquaComponent)

for (Variabele in Componenten) {
  data_figuur <- data_TVG %>%
    filter(AquaComponent %in% Variabele)
  figuur <- ggplot(data_figuur,
                   aes(x = ResultCalc, y = codeplas)) +
    geom_boxplot() +
    labs(title = paste0("Turnhout variabele ",data_figuur$label, "\n")) +
    ylab("Locatie") + xlab(paste0("Meetwaarde (", data_figuur$AquaUnit ,")"))
  ggsave(figuur,
         filename = paste0("./exports/boxplots/", "Turnhout_",Variabele, "_bw",".jpg"), width = 1080, height = 720, units = "px", scale = 3)
}
```

# functies
```{r}
# genereer plot en sla op
save_plot <- function(dataset, component, naam, title = NULL, xas = NULL, yas = NULL){
  figuur <- dataset %>%
    filter(AquaComponent %in% component) %>%  
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, color = Label, linetype = CODE)) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b-%Y") + # visualiseert data per maand in format maand-jaar
    geom_line(linewidth = 1) +
    geom_point() +
    labs(title = title) + xlab(xas) + ylab(yas)
  print(figuur)
  ggsave(plot = figuur,
         filename = paste0("./exports/NKP_", naam, ".jpg"), width = 9, height = 6)
}

# puur om plot te genereren
maak_plot <- function(dataset, component, title = NULL, xas = NULL, yas = NULL){
  figuur <- dataset %>%
    filter(AquaComponent %in% component) %>%  
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, color = label)) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b-%Y") + # visualiseert data per maand in format maand-jaar
    geom_line(linewidth = 1) +
    geom_point() +
    labs(title = title) + xlab(xas) + ylab(yas)
  figuur
}

# plots genereren voor 1 variabele (voor 1 locatie)
maak_plot_1var <- function(dataset, component, title = NULL, xas = "Datum staalname", yas = NULL){
  figuur <- dataset %>%
    filter(AquaComponent %in% component) %>%  
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc)) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b-%Y") + # visualiseert data per maand in format maand-jaar
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1, color = "orange") +
    geom_point(color = "orange") +
    labs(title = title) + xlab(xas) + ylab(yas)
  figuur
}

# voor 1 variabele voor alle locaties
maak_plot_1var_loc <- function(dataset, component, title = NULL, xas = "Datum staalname", yas = NULL){
  figuur <- dataset %>%
    filter(AquaComponent %in% component) %>%  
    ggplot(aes(x = FieldSamplingDate, y = ResultCalc, color = CODE)) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b-%Y") + # visualiseert data per maand in format maand-jaar
    scale_y_continuous(breaks = pretty_breaks(n = 10)) +
    geom_line(linewidth = 1) +
    geom_point() +
    labs(title = title) + xlab(xas) + ylab(yas)
  figuur
}
```


# Maucha-diagram

## originele code Maucha (per plas figuur opslaan)
```{r}
maucha <- function(x, col = NULL,
                   labels = TRUE, labels.col = 1,
                   polygon = FALSE, polygon.col = 1,
                   main = NULL, ...){
  
  if(is.null(col)){
    col <- c("#54c7fd", "#ffcd00", "#ff9600", "#ff2851",
             "#0076fe", "#41cd58", "#ff3823", "#8f8e94")
  }
  col <- rep_len(col, length.out = 8)
  polygon.col <- rep_len(polygon.col, length.out = 8)
  
  if(is.vector(x)){
    n.plot <- 1
    x.all <- t(as.matrix(x))
  } else {
    x.all <- as.matrix(x)
    n.plot <- nrow(x.all)
    if(is.null(main)){
      main <- row.names(x.all)
    }
  }
  
  par.mar.0 <- par("mar")
  par.mfrow.0 <- par("mfrow")
  par(mfrow = c(.dimMosaic(n.plot)[1], .dimMosaic(n.plot)[2]),
      mar = c(2, 0, 2, 0))
  
  for(j in 1:n.plot){
    
    x <- x.all[j, ]
    
    x[1] <- (x[1] * 1) / 39.0983
    x[2] <- (x[2] * 1) / 22.9898
    x[3] <- (x[3] * 2) / 40.0780
    x[4] <- (x[4] * 2) / 24.3050
    x[5] <- (x[5] * 2) / 96.0626
    x[6] <- (x[6] * 1) / 35.4530
    x[7] <- (x[7] * 1) / 61.0168
    x[8] <- (x[8] * 2) / 60.0089
    
    x[1:4] <- x[1:4] / sum(x[1:4]) * 100
    x[5:8] <- x[5:8] / sum(x[5:8]) * 100
    
    A  <- sum(x)
    R <- sqrt(((A / 16) * 2 / sin(22.5 * pi / 180)))
    a <- x / (R * sin(22.5 * pi / 180))
    
    
    coord.x <- matrix(NA, nrow = 5, ncol = 8)
    coord.y <- matrix(NA, nrow = 5, ncol = 8)
    coord.x[1, ] <- coord.x[5, ] <- rep(0, 8)
    coord.y[1, ] <- coord.y[5, ] <- rep(0, 8)
    coord.x[2, ] <- cos(seq(90, -225, -45) * pi / 180) * R
    coord.y[2, ] <- sin(seq(90, -225, -45) * pi / 180) * R
    coord.x[3, ] <- cos(seq(67.5, -247.5, -45) * pi / 180) * a
    coord.y[3, ] <- sin(seq(67.5, -247.5, -45) * pi / 180) * a
    coord.x[4, ] <- cos(seq(45, -270, -45) * pi / 180) * R
    coord.y[4, ] <- sin(seq(45, -270, -45) * pi / 180) * R
    
    
    if(polygon | labels){
      coord.poly.x <- coord.x
      coord.poly.x[3, ] <- cos(seq(67.5, -247.5, -45) * pi / 180) * R
      coord.poly.y <- coord.y
      coord.poly.y[3, ] <- sin(seq(67.5, -247.5, -45) * pi / 180) * R
    }
    
    if(labels){
      lab <- c("K", "Na", "Ca", "Mg", "SO4", "Cl", "HCO3", "CO3")
      lab.pos.x <- coord.x[3, ]
      lab.pos.y <- coord.y[3, ]
      lab.pos.x[a < R] <- coord.poly.x[3, a < R]
      lab.pos.y[a < R] <- coord.poly.y[3, a < R]
      lab.pos.x <- lab.pos.x + cos(seq(67.5, -247.5, -45) * pi / 180) * 2
      lab.pos.y <- lab.pos.y + sin(seq(67.5, -247.5, -45) * pi / 180) * 2
    }
    
    
    xlim <- max(abs(c(min(lab.pos.x), max(lab.pos.x))))
    ylim <- max(abs(c(min(lab.pos.y), max(lab.pos.y))))
    plot(0, 0, type = "n", xlim = c(-xlim, xlim), ylim = c(-ylim, ylim),
         xaxt = "n", yaxt = "n", xlab = "", ylab = "", asp = 1, bty = "n", main = main[j], ...)
    
    for(i in 1:8){
      polygon(x = coord.x[, i], y = coord.y[, i], col = col[i], border = NA)
      if(polygon){
        lines(x = coord.poly.x[, i], y = coord.poly.y[, i], col = polygon.col[i])
      }
    }
    
    if(labels){
      text(lab.pos.x, lab.pos.y, lab, col = labels.col)
    }
  }
  par(mar = par.mar.0, mfrow = par.mfrow.0)
}

# Compute a grid for graphical arrangement
.dimMosaic <- function(n.plot){
  x <- floor(sqrt(n.plot))
  y <- floor(sqrt(n.plot))
  if(x * y < n.plot) y <- y + 1
  if(x * y < n.plot) x <- x + 1
  return(c(x, y))
}
```

## Maak dataset met ionen
```{r}
# dataset met ionen (gemiddelde waarde per locatie)
ionen <- data_TVG %>%
  filter(AquaComponent %in% c("K", "Na", "Ca", "Mg", "SO4", "Cl", "HCO3_OEP", "CO3")) %>%
  group_by(AquaComponent, codeplas) %>%
  summarise(gemiddelde = mean(ResultCalc))

# to wide format
ionenwide <- pivot_wider(ionen, names_from = AquaComponent, values_from = gemiddelde)
ionenwide <- ionenwide %>% select(codeplas, K, Na, Ca, Mg, SO4, Cl, HCO3_OEP, CO3)
```


### Maucha-diagram voor alle locaties (gemiddelde per locatie)
```{r}
# converteer kolom met locatiecode naar row.names voor maucha-functie
ionenwide <- ionenwide %>% remove_rownames %>% column_to_rownames(var = "codeplas")
maucha(ionenwide)
```

# IR-EGV plot
```{r}

```

